---
layout:     post
title:      "JUC"
subtitle:   " \"一百天也要学完JUC\""
date:       2026-1-27 12:00:00
author:     "HZY"
header-img: ""
catalog: true
tags:
    - Java
---

 
### 预备知识
##### 进程与线程
* 进程的概念:

* 线程的概念:

* 对比:
    * 进程几乎相互独立
    * 进程内数据，可供内部线程共享
    * 进程间通信复杂
    * 线程通信相对简单
    * 线程更加轻量级

##### 并行与并发
* 操作系统的任务调度器
    * 对于单核的cpu:微观串行,宏观并行
    * 多核cpu
* 并发: 同一时间应对多件事情的能力
* 并行: 同一时间动手做多件事情的能力

##### 同步与异步
* 同步
* 异步

### 线程
##### Thread
* 直接使用Thread
* `Thread`与`Runnable`

``` java
@Test
public void test02() throws InterruptedException {
    Thread thread = new Thread(
            ()-> cout.print("我启动了")
            //cout是作者自定义的一个red_printer
    ) ;
    thread.setName("thread2");
    thread.start();

    thread.join();
}
```

* `FutureTask`实现了`Runnable`接口，所以也可以扔给task
    * `task.get()`会阻塞线程直到拿到值

``` java
@Test
public void test03() throws InterruptedException, ExecutionException {
    FutureTask<String > task = new FutureTask(()->{
        cout.print("我也喜欢你");
        return "这是我的答案！！！love you too";
    });

    Thread thread = new Thread(task);
    thread.setName("表白线程");

    thread.start();
    System.out.println("我喜欢你，可以给我答复吗");
    cout.print( task.get());
}
```

##### 进程命令
``` bash
tasklist   
taskkill 

jps  #查看所有java线程
jstack <PID>  #查看某个java进程的所有线程状态
jconsole   #查看某个java进程中线程的运行情况
```

##### 线程运行原理

* 栈:
    * 栈帧:
* 堆:
* 方法区 

* 栈帧图解:
* 线程上下文切换:
    * 线程数过多，频繁切换上下文会使得效率变低

##### 常见方法
``` java
run();
join();
getId();
getName();
getState();
isInterrupted();
isAlive();
interrupt();
interrupter();
Thread.currentThread();
sleep();
yield();
```
* 直接new Thread重写`run()`方法已经在jdk17+不再推荐使用
    * 这里简短的说明一下`start()`与`run()`方法，调用run方法就是把run拿到当前线程，而不是新建立了一个线程

##### sleep和yield
* sleep之后会进入线程阻塞状态`Timed Waiting`
    * `intercepter`可以打断睡眠，睡眠被打断会抛出异常`InterruptedException`
    * 睡眠结束后的线程未必立即执行
    * `TimeUnit.sleep()`方法可读性更高

* `yield`使得当前线程从`Running`变为`Runnable`
    * 具体实现靠任务调度器

* 区别:
    * `yield`没有等待时间
    * `sleep`之后，任务调度器一定不会分配资源

##### 线程优先级
* 默认5,最大10，最小1
* 优先级不靠谱，仅仅作为一个提示 (但是是能用)
    * 在任务紧张,才会有用，cpu空闲时候，几乎无用

##### 案例
* 我们在做服务端使用while(true)的时候,记得使用`sleep(50)`，不要让cpu被100%占用，让出一部分时间
* sleep适用于无需锁同步的场景

##### join方法
* 为什么用`join`而不用`sleep`
* `join`等待线程结束
* join实现同步:需要等待结果返回
* `join(n)` java喜欢用毫秒

##### interrupt打断
* 打断sleep,wait,join：
    * 打断之后，`isinterrupted`就会变为`true`，但是，程序内部一直在检查这个值，一旦看到为`true`就会抛出一个`InterruptedException`,然后将状态重置为`false`,程序可以在try-catch中捕获异常来自定义进行打断之后的操作
* 打断正在运行的线程: `isinterrupted`就会变为`true`,线程可以自己检查自己的`isinterrupted`属性，进行判断然后自定义逻辑
* `interrupted()`会清除打断标记
* `isInterrupted()`判断是否被打断


##### 两阶段终止模式
* 如何在t1线程中 “优雅地”终止t2线程
* 禁止使用`stop()`方法
    * `stop()`会真正直接杀死程序，有些资源的锁无法释放，那就完蛋了
* 绝对禁止`System.exit(int)`直接终止程序
* 实现思路：`while(ture)`中要判断打断标记，如果标记为`true`就执行释放逻辑。对于抛出异常的情况，我们在catch里面只需要再把打断标记置为true，走判断打断标记的逻辑

##### 打断park线程
* `LockSupport.park()`阻塞线程
* 直接打断
* 打断标记为`true`的时候不能再次`park()`了：park失效

##### 不推荐的方法
* `stop()`
* `suspend()`
* `resume()`

##### 守护线程
* Java 进程会等待所有非守护线程结束后才会结束，守护线程即使没有执行完，进程也会强制结束
* 垃圾回收是一种守护线程

``` java
@Test
    public void test06() throws InterruptedException, ExecutionException {
        Thread t1 = new Thread(()->{
            cout.print("我是新线程1，我要开始叫了");
            Thread thread = new Thread(()->{
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
                cout.print("我是小线程，我睡了1s");
            });
            thread.start();
        });
        t1.start();

        t1.join();
        cout.print("t1已经死了结束了");
        Thread.sleep(2000);
        System.out.println("主线程结束");
    }
```

这个例子你可以清楚的看到，java确实是`默认非守护线程`
因为t1.join()结束以后,t2仍然执行了打印(注意主程序一定要等一等子线程)，不然看不到打印结果

##### 五种状态--操作系统
* 初始状态
* 可运行状态(就绪状态)
* 运行状态: 获得了cpu时间片
* 阻塞状态：
    * 调用了阻塞API,cpu不会分配资源
    * 与可运行状态的区别是，对阻塞状态的线程来说，只要它们一直不唤醒，调度器就一直不会考虑调度他们
    *  还有活的可能
* 终止状态:生命周期结束了，死翘翘了

##### 线程的六种状态————JAVA中
* NEW
* RUNNABLE
    * 运行
    * 阻塞：执行阻塞api
    * 可运行
* TERMINATED
    * 结束了 
* BLOCKED: 阻塞
* WAIRING: 阻塞，如`wait()`
* TIMED_WAITING: 有时限的阻塞，如`sleep`

### 共享模型之管程
例子引入
``` java
public class ThreadTest2 {
    int count = 0 ;

    @Test
    public void test() throws InterruptedException {
        Thread thread = new Thread(()->{
            for (int i = 0; i < 10000; i++) {
                count++;
            }
        });
        Thread thread2 = new Thread(()->{
            for (int i = 0; i < 10000; i++) {
                count--;
            }
        });

        thread.start();
        thread2.start();

        thread.join();
        thread2.join();
        System.out.println(count);
    }
}
```
在多线程同时对一个数据进行写操作就会导致资源共享问题

* 临界区: 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区
* 竞态条件: 多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件

#### 互斥
* 阻塞式: synchronized, Lock 
* 非阻塞式: 原子变量
##### synchronized
* 用`synchronized`代码块包住`临界区代码`
* 需要拿到对象锁才能执行临界区代码
* 其他线程会进行`BLOCKED`状态

``` java
@Test
public void test() throws InterruptedException {
    Thread thread = new Thread(()->{
        synchronized ( lock){
            for (int i = 0; i < 10000; i++) {
                count++;
            }
        }
    });
    Thread thread2 = new Thread(()->{
        synchronized (lock){
            for (int i = 0; i < 10000; i++) {
                count--;
            }
        }
    });
    thread.start();
    thread2.start();
    thread.join();
    thread2.join();
    System.out.println(count);
}
```

* 只要拿到锁，别人就拿不到资源，即使自己没有时间片的分配
* `synchronized`执行结束之后，就会唤醒其他线程
* 原子性
* 锁对象

``` java
//基于面向对象的改造
class Room{
    private int count = 0 ;
    
    public void addCount(){
        synchronized (this){
            count++;
        }
    }
    
    public void minusCount(){
        synchronized (this){
            count--;
        }
    }
    
    public int getCount(){
        synchronized (this){
            return count;
        }
    }
}

//可以优化
class Room{
    private int count = 0 ;
    public synchronized void addCount(){
        count++;
    }
    public synchronized void minusCount(){
        count--;
    }
    public synchronized int getCount(){
        return count;
    }
}
```
* 上面都是对象锁，锁住的是对象的资源
* 针对于静态方法等，还有类锁等东西，用于同时对所有对象加锁，这一点很好理解

##### 线程安全分析
* 局部变量不需要加锁