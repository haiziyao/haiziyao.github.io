---
layout:     post
title:      "SSM复习 ? "
subtitle:   " \"成为J佬的一天\""
date:       2025-12-14 12:00:00
author:     "HZY"
header-img: "img/java/1.png"
catalog: true
tags:
    - Java
---
## 写在前面
* TOC
{:toc}



### Spring容器

* 组件
    * Servlet
    * Service
    * Dao
* 容器
    * Servlet容器

##### IoC 和 DI
* Inversion of Control
* Dependency Injection

##### @Bean
* 组件不存在,异常：NoSuchBeanDefinitionException
* 组件不唯一,使用了getBean(Class),异常:NoUniqueBeanDefinitionException
* 使用getBeansOfType()


``` java
//组件注册
@Bean("zhangsan")
public Person zhangsan(){
    var person = Person.builder().age(10).sex(1).name("我是傻逼").build();
    return person;
}
```
组件创建是在容器创建过程中创建的，容器创建完成的时候，组件早已注册完成
组件是单例的
##### @Configuration  
配置类，可以放置所有组件的定义和声明

##### @Service,@Controller,@Repository
以上都可以使用@Component代替，上面的三个注解底层都是Component，是给人看的，不是给机器看的

@ComponentScan扫描

##### @Import
我们想使用导入的包的类作为bean，由于导包是只读的
所以我们要么： 自己new一个，要不直接导入
``` java
@Bean
public NBClass nbclass(){
    return new NBClass;
}


//方法二直接导入
@Import(NBClass.Class)
```
##### @Scope
@Scope("prototype")  懒加载，多例
组件对象什么时候用什么时候创建

@Scope("singleton")  单实例，在容器创建之前就创建了
@Lazy  可以让单例模式变为懒加载

@Scope("request")
@Scope("session")
##### FactoryBean
属于一个Class的bean，name是BYDFactory
``` java
@Component
public class BYDFactory implements FactoryBean<Car> {

    @Override
    public Car getObject() throws Exception {
        return new Car();
    }

    @Override
    public Class<Car> getObjectType() {
        return Car.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
```
##### @Conditional
![alt text](/img/java/image6.png)
这个很好玩，spring实现了很多子类
``` java
@ConditionalOnResource(resources = "")
@Conditional(CarContional.class)
@Bean
public Car car1(){
    return new Car();
}
```

##### @Autowired自动装配
如果找到一个，直接注入，找到等多个，按照名字去找,变量名就是名字
``` java
@Autowired
List<Person> persons;

@Autowired
Map<String,Person> personMap;
```
@Resource也能进行自动装配，不过这个是jdk标准规定的东西。
而@Autowired是spring的,而且能开启(required=false)，功能更强
##### @Qualifier("")  @Primary
@Qualifier精确指定，
@Primary指定默认组件,优先级最高
属性名对应优先级最低
##### 利用有参构造器进行装配
spring推荐的方法
``` java
public calss UserDao{
    Dog haha;
    //spring会自动在容器里面找东西吃，然后扔给UserDao
    public UserDao(Dog dog){
        this.haha = dog;
    }
}
```
##### setter注入
其实还可利用setter进行注入，就是给setter上面标注@Autowired
``` java
public void setDog(@Qualifer("dog1") Dog dog){
    this.dog = dog ;
}
```

##### XXXAware感知接口
如果我想在一个类里面使用环境变量等东西，我可以实现Environment接口，然后在自定义一个field接受面量，这样就可以使用了
##### @Value注入值
``` java
@Value("字面值")

@Value("${dog.name:哈哈}") //默认从动态文件application.properties中取出来,可以用冒号赋值默认值
@PropertySource("classpath:cat.properties")  //注意这个注解是加载的意思，而不是仅用这个文件的意思，
// 是在原有文件之上再加载，所以理论上直接放在最外层或者Config层都行

@Value("#{SpEL}")  //表达式
@Value("#{T(java.util.UUID).randomUUID().toString()}")
```
##### 数据源配置
如果我们有开发，测试，生产三套数据源
其实我们想想就知道我们可以用条件注解进行选择
@Profile("")  底层就是@Conditional
``` java
@Prifile("dev")
@Prifile("test")
@Prifile("prod")
@Prifile("default")  //必须得有一个default

@Prifile({"dev",defalut})

//在application.properties中
spring.profiles.active = prod //即可切换
```
 
##### 生命周期
默认单例模式：
构造器    //创建周期
->postProcessBeforeInitiallization   
->@Autowired set属性注入->@PostConstruct ->afterPropertiesSet->init   // 初始化周期
->postProcessAfterInitiallization
->容器创建,运行中   //运行周期
->@Predestroy->destroy->destory方法   //销毁周期
* InitializingBean: afterPropertiesSet
* DisposableBean  : destroy
* @PostConstruct 
* @Predestroy
* BeanPostProcessor : 外挂修改器,
    * postProcessBeforeInitiallization
    * postProcessAfterInitiallization

    上面这俩方法是一个统一的拦截器，拦截所有人

举例
* AutowiredAnnotationBeanPostProcessor
我们自己研究源码，实现了一个@UUID的注解，具体见手撕源码

### AOP事务
Aspect Oriented Programming 面向切面编程
##### 静态代理类
我们对每一个实现类都要去创建一个代理实例，这样使得代码更加复杂
虽然使用到了代理技术，但是依旧差强人意

##### 动态代理类
优点： 在运行时才确定代理对象
缺点： 带的对象必须有接口
``` java
public class DynamicProxy {

    public static Object getDynamicProxy(Object obj){
        var proxyInstance = Proxy.newProxyInstance(
          obj.getClass().getClassLoader(),
          obj.getClass().getInterfaces(),
                (proxy,method,args) -> {
                    System.out.println("在你执行之前：");
                    var result = method.invoke(obj,args);
                    System.out.println("在你执行之后");
                    return result;
                }
        );

        return proxyInstance;
    }
}

```
##### 封装LogUtil

##### AOP
* 前置通知
* 返回通知
* 异常通知
* 后置通知

切入表达式的写法：

``` java
package com.hzyxsj.javassmaop.aspect;

import org.aspectj.lang.annotation.*;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

/**
 * 作者：宇宙超级无敌大马猴
 * 姓：亥
 * 字：子曜
 * 号：栖逸居士
 * 版本号：随缘
 */

@Component
@Aspect
public class LogAspect {
    @Before("execution(int add(int,int))")
    public void logBefore(JoinPoint joinpoint){
        System.out.println("this is the logBefore");
    }
    @AfterReturning(value ="execution(int add(int,int))"，returning = "result")
    public void logAfterReturning(JoinPoint joinpoint,Object result){
        System.out.println("this is the logAfterReturning");
    }

    @AfterThrowing(value = "execution(int add(int,int))",
    throwing = "e")
    public void logAfterThrowing(JoinPoint joinpoint,Exception e){
        System.out.println("this is the logAfterThrowing");
    }
    @After("execution(int add(int,int))")
    public void logAfter(JoinPoint joinpoint){
        System.out.println("this is the logAfter");
    }

}
//切入点表达式的写法
execution(方法的全签名)
[public] int [com..Class].MethodName(int,int) [throw] 
//要好好写切面表达式，不然就炸了
//其他写法
//within this  target都不重要，我都听着睡着了
//重点  args
@Before(execution(args(int,int)))
//这里定义切面的方式非常多
//老师讲的比较乱，所以以后可以补一补这里
```
增强器链： 切面中的所有方法其实就是增强器，他们被组织成一个链路放到集合中，
      
流程：前置->目标方法->返回->结束方法
前置->目标方法->异常返回->结束方法

>对于切入面，你的返回修饰符和返回值没有规定，但是参数有严格规定
如果想拿到信息，就用切入点(JoinPoint joinPoint)

``` java
@Pointcut("切入点表达式")
public class pointCut(){}

@Before(value="pointCut()")

//多切面如何运行
//相当于套娃，层层嵌套
  前置1 ->前置2->返回或异常2->后置2->返回或异常1->后置1
//对于类型名一般默认按照首字母排序
//但我们可以手动排序
@Order(1)  //数字越小，优先级越高，越是外层
```
#####  工具类
* AnnotationUtils工具类
* ClassUtils
* TypeUtils
* ReflectionUtils  

##### 源码
Sping如何找组件，三级缓存机制
1. 先去singletonObject单例对象池(成品区)
2. earlySingletonObjects去早期单例对象池里面找(半成品区)
3. 加锁，再去上面两个地方再找一次
4. singtonFactories去单例工厂找(最后才会用工厂制造)

3和4即为三级缓存机制
##### @Aroud
环绕通知，
如果不加Order排序，环绕就在最外层
``` java
@Aspect
@Component
public class LogAround {
    @Pointcut("execution(int add(int,int))")
    public void getCut(){
    }
    @Around("getCut()")
    public  Object aroundlog(ProceedingJoinPoint pjp) throws Throwable {
        Object[] args = pjp.getArgs();
        System.out.println("进行前置通知");
        Object result = null   ;
        try {
            result = pjp.proceed(args);
            System.out.println("this is the AfterReturning");
        } catch (Throwable e) {
            System.out.println("this is the AfterThrowing Around");
        } finally {
            System.out.println("this is the After Around");
        }
        return result;
    }
}
```

##### 自动配置数据源
``` yaml
spring.datasource.url=jdbc:mysql://localhost:3306/spring_tx
spring.datasource.username=root
spring.datasource.password=123456
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

//自己写个@Autowired就拿到Datasource了
```
##### 事务
@EnableTransacctionManagement
@Transactional
原理：
* 事务管理器TransactionManager 控制提交和回滚
* 事务拦截器TransactionInterceptor 控制何时提交和回滚


* timeout 超时时间

>这个timeout只记录到最后一次dao操作的时间，如果是dao之后执行了很长时间其他代码，不会造成超时
* isolation 隔离级别
* readOnly = true  

>可以开启只读优化，因为读不需要事务
* RollbackFor = {IOException.class}  

>指明哪些异常需要回滚，不是所有异常都会造成回滚
回滚的默认机制：运行时异常回滚，编译异常不回滚
使用rollbackFor是额外指定可以回滚的异常

* noRollbackFor = {}

>和上面相反

* 隔离级别isolation
    * READ_
        * 脏读
        * 不可重复读
    * READ_COMMIT
        * 不可重复读
    * REPEATBLE_READ  (快照读，mySql默认)
        * 幻读
* 传播行为Propagation
 
| 传播行为          | 是否新建事务 | 是否加入事务 | 无事务时表现 | 异常时影响 |
| ------------- | ------ | ------ | ------ | ----- |
| REQUIRED      | 可能     | 是      | 新建事务   | 整体回滚  |
| SUPPORTS      | 否      | 可选     | 非事务    | 仅当前   |
| MANDATORY     | 否      | 必须     | 抛异常    | 整体    |
| REQUIRES_NEW  | 是      | 否      | 新建事务   | 独立    |
| NOT_SUPPORTED | 否      | 否      | 非事务    | 无回滚   |
| NEVER         | 否      | 禁止     | 正常     | 抛异常   |
| NESTED        | 可能     | 是      | 新建事务   | 局部回滚  |

小事务和大事务公用一个事务，小事务自己的设置失效，比如timeout，只能看大事务的

### SpringMVC



##### MVC 
``` java
@Controller
@ResponseBody
//这俩可以合体，标在类上
@RestController

@RequestMapping("/hello")  //路径映射
@RequestMapping("/hello?") //任意一个字符
@RequestMapping("/hello*")  //任意多个字符  
@RequestMapping("/hello**")  //任意层级
//精确优先  
//属性限定
value = ""
// GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS,TRACE
method = {RequestMethod.POST,RequestMethod.GET}  

params = "username"  //必须给我一个username
params = "age=18"   //必须有给我age=18
params = {"!username"}

headers = {"haha"}

consumes = "application/json"  
consumes = "text/html" //必须携带数据
```
##### Http请求
http端口就是80，https端口是443

* protocol
* Domain Name
* Port 
* Path
* Parameters
* Anchor

##### 示例
获取参数的方法，直接使用相同变量名在方法参数中，就直接能获取到 
``` java
@RequestParam("Username") String name //默认必须携带
@requestParam(value = "Password", required = false) String password
@requestParam(value = "Password", defaultValue = "66666") String password

```
* POJO封装
如果参数是一个POJO，底层会自己封装进去Field
每个参数都是非必须的
* 其他获取

``` java
//请求头
@RequestHeader("host") String host

//cookie获取
@CookieValue("ck") String ck 

//POJO支持级联封装


//获取请求体数据json变为POJO
(@RequestBody Person person)

//文件上传
@RequestParam("headerImg") MultipartFile headerImgFile,
@RequestParam("lifeimg") MultipartFile[] lifeimgs

String originalname = headerImgFile.getOriginalFilename();
//还可以进行许多操作
headerImgFile.transferTo(new File(path));  //直接干啦

//SpringMCV默认有上传文件大小1MB
//自己改配置spring.servlet.multipart.max-file-size=1GB

(HttpEntity<Person> entity) //直接拿到整个请求
entity.getBody();   //泛型就是请求体的类型
entity.getHeaders();


//支持你的servelt
```

response
``` java
//返回json，MVC会自己转json
@ResponseBody  //已经封装到RestController里面了
return POJO;
return Map; 

//文件下载
@GetMapping("/download/stream")
public ResponseEntity<InputStreamResource> downloadStream() throws IOException {

    File file = new File("path");
    InputStreamResource resource =
            new InputStreamResource(new FileInputStream(file));

    String encodedFileName = URLEncoder.encode("中文.txt", StandardCharsets.UTF_8).replaceAll("\\+", "%20");

    return ResponseEntity.ok()
            .contentType(MediaType.APPLICATION_OCTET_STREAM)
            .contentLength(file.length())
            .header(HttpHeaders.CONTENT_DISPOSITION,
                    "attachment; filename*=UTF-8''" + encodedFileName)
            .body(resource);
}


//页面跳转
Thymeleaf 

这个直接跳过了，后面应该不可能了解这个了
```

##### RESTful 资源状态转移
Resource Representational State Transfer

| URI               | 请求方式   | 请求体           | 作用     | 返回数据                |
| ----------------- | ------ | ------------- | ------ | ------------------- |
| `/employee/{id}`  | GET    | 无             | 查询某个员工 | Employee JSON       |
| `/employee`       | POST   | employee JSON | 新增某个员工 | 成功 / 失败状态           |
| `/employee`       | PUT    | employee JSON | 修改某个员工 | 成功 / 失败状态           |
| `/employee/{id}`  | DELETE | 无             | 删除某个员工 | 成功 / 失败状态           |
| `/employees`      | GET    | 无 / 查询条件      | 查询所有员工 | List<Employee> JSON |
| `/employees/page` | GET    | 无 / 分页条件      | 分页查询员工 | 分页数据 JSON           |

Controller->Service->Dao
>Service层经常在干嘛，就是再把Dao封装了一层，作为一个代理
我可以把controller传来的数据进行再次处理，比如进行非空处理


``` java
@GetMapping(value = "/employee/{id}")
public String get(@PathVariable Long id)

//封装返回数据
@Data
public class R<T> {
    private int code;
    private String msg;
    private T data;

    private R(int code, String msg, T data) {
        this.code = code;
        this.msg = msg;
        this.data = data;
    }

    public static <T> R<T> ok(T data) {
        return new R<>(ResultCode.SUCCESS.getCode(),
                       ResultCode.SUCCESS.getMsg(),
                       data);
    }

    public static <T> R<T> fail(ResultCode code) {
        return new R<>(code.getCode(), code.getMsg(), null);
    }
}

public enum ResultCode {

    SUCCESS(200, "成功"),
    PARAM_ERROR(400, "参数错误"),
    UNAUTHORIZED(401, "未登录"),
    FORBIDDEN(403, "无权限"),
    NOT_FOUND(404, "资源不存在"),
    SERVER_ERROR(500, "服务器异常");

    private final int code;
    private final String msg;

    ResultCode(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public int getCode() { return code; }
    public String getMsg() { return msg; }
}

```
##### 跨域问题
http://localhost
http"//localhost:8080 
上面这两个甚至也算是跨域请求
@CrossOrigin  允许跨域请求

##### 拦截器HandlerIterceptor
拦截器是给类配置的，实现HandlerIterceptor接口
``` java
@Component
public class Myinterpretor implements HandlerInterceptor {
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception {
        System.out.println("this is the postHandle method");
        HandlerInterceptor.super.postHandle(request, response, handler, modelAndView);
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("this is the preHandle method");
        return HandlerInterceptor.super.preHandle(request, response, handler);
    }
}

//要使用拦截器，首先要添加拦截器,我们使用配置类
@Configuration
public class MyConfiguration implements WebMvcConfigurer {
    @Autowired
    Myinterpretor interpretor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
         registry.addInterceptor(interpretor).addPathPatterns("/**");
    }
}


//多个拦截器
pre顺序执行
post倒序执行
```

**注意WebConfiguration**

##### 声明式异常处理
@ExceptionHandler(ArithmeticException.class)
``` java

@ExceptionHandler(ArithmeticException.class)
public String ArithmeticExceptionHandler(ArithmeticException ex){
    System.out.println("this is ArithmeticException");
    return ex.getMessage();
}

//但是这个只能在一个类中使用，出了类就不行了
```
全局处理异常@ControllerAdvice
``` java
@Configuration
public class MyConfiguration implements WebMvcConfigurer {
    @Autowired
    Myinterpretor interpretor;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
         registry.addInterceptor(interpretor).addPathPatterns("/**");
    }
}
```
异常处理流：本类处理->全局处理->SpringBoot底层兜底

在一些业务中，我们更希望遇到一些业务上的问题的时候，不仅仅是空值处理，我们更希望你可以抛出异常，通知上层组件。
我们更希望能够抛出自定义异常。
``` java
@Getter
public class BizException extends RuntimeException {
    
    private final String code;
    //不用写msg ， 因为RuntimeException 自带有这个msg字段
    public BizException(BizExceptionEnum bizEnum) {
        super(bizEnum.getMsg());
        this.code = bizEnum.getCode();
    }

    public BizException(BizExceptionEnum bizEnum, Throwable cause) {
        super(bizEnum.getMsg() );
        this.code = bizEnum.getCode();
    }
}

@Getter
public enum BizExceptionEnum {

    ORDER_NOT_EXIST("100", "订单不存在"),
    PARAM_ERROR("400", "参数错误");

    private final String code;
    private final String msg;

    BizExceptionEnum(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }
}

```

##### 数据校验
JSR303 为Bean进行校验
``` java
public class Person {
    @NotBlank(message="不能啥也没有")
    private String name;

    @NotNull
    @Max(value= 150 ,message = "不能大于150岁")
    @Min(value = 0 ,message = "不能太小了 ")
    private int age;


    @Email
    private String email;
}

//注意以上还没开启校验，需要在方法参数处使用@Valid
public void test(@RequestBody @Valid Person person,BindingResult result){
    if(result.hasErrors()){
        return ok();
    }
    Map<String,String> errorMap = new HashMap<>();
    for(FieldError fielderror:result.getFieldErrors){
        String field = fielderror.getField();
        String message = fielderror.getDefaultMessage();
        errorsMap.put(field,message);
    }
    return error(......,errorMap)
}
//上面这种方式不好，不方便
//我们不需要写，因为我们有全局异常处理器
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public String exceptionHandler(MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        Map<String,String> errorMap = new HashMap<>();
        for(FieldError fielderror : bindingResult.getFieldErrors()){
            String field = fielderror.getField();
            String message = fielderror.getDefaultMessage();
            errorMap.put(field,message);
        }
        return errorMap.keySet().toString();
    }
//直接这样封装全局的就好了
//对于异常的匹配，底层默认是精确匹配，越精确，越匹配，


//我们可以写正则表达式 
@Pattern(regexp="",message="")


//自定义校验注解
//这里了解一下有这种需求就好了，实际上我感觉挺复杂


//国际化 i18n  
@NotNul(message ="{去配置文件里面拿}")  //放在message.properties里面
配置不同语言的properties
message_zh_CN.properties

//分组校验
// 我们会说，在CRUD不同场景都会有不同的参数校验
//但是把各种注解标在field的脑子上面，各种功能放在一起不好
//所以我们有TO，DAO，VO等等
BeanUtils.copyProperties(employee,vo);
List<EmployeeRespVo> result = employees.stream().
        map(employee -> {
            var vo = new EmployeeRespVo();
            BeanUtils.copyProperties(employee,vo);
            return vo;
        })
```
**推荐文章1：各种O傻傻分不清**
##### 接口文档
* Swagger : 遵循OpenAPI规范
* Knife4j ：增强Swagger

``` java
@Tag(name = "写在类上，如：员工管理")
@Operation(summary = "add一个新员工，写在方法上")
@Schema(description = "员工表,放类上")
@Schema(description = "员工id，放field上")
```
##### 日期处理
@JsonFormat(pattern = "" ,timezone="GMT+8")

##### SpringMVC源码
先跳过了