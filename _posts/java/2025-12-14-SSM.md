---
layout:     post
title:      "SSM复习 ? "
subtitle:   " \"成为J佬的一天\""
date:       2025-12-14 12:00:00
author:     "HZY"
header-img: "img/java/1.png"
catalog: true
tags:
    - Java
---

* 组件
    * Servlet
    * Service
    * Dao
* 容器
    * Servlet容器

##### IoC 和 DI
* Inversion of Control
* Dependency Injection

##### @Bean
* 组件不存在,异常：NoSuchBeanDefinitionException
* 组件不唯一,使用了getBean(Class),异常:NoUniqueBeanDefinitionException
* 使用getBeansOfType()


``` java
//组件注册
@Bean("zhangsan")
public Person zhangsan(){
    var person = Person.builder().age(10).sex(1).name("我是傻逼").build();
    return person;
}
```
组件创建是在容器创建过程中创建的，容器创建完成的时候，组件早已注册完成
组件是单例的
##### @Configuration  
配置类，可以放置所有组件的定义和声明

##### @Service,@Controller,@Repository
以上都可以使用@Component代替，上面的三个注解底层都是Component，是给人看的，不是给机器看的

@ComponentScan扫描

##### @Import
我们想使用导入的包的类作为bean，由于导包是只读的
所以我们要么： 自己new一个，要不直接导入
``` java
@Bean
public NBClass nbclass(){
    return new NBClass;
}


//方法二直接导入
@Import(NBClass.Class)
```
##### @Scope
@Scope("prototype")  懒加载，多例
组件对象什么时候用什么时候创建

@Scope("singleton")  单实例，在容器创建之前就创建了
@Lazy  可以让单例模式变为懒加载

@Scope("request")
@Scope("session")
##### FactoryBean
属于一个Class的bean，name是BYDFactory
``` java
@Component
public class BYDFactory implements FactoryBean<Car> {

    @Override
    public Car getObject() throws Exception {
        return new Car();
    }

    @Override
    public Class<Car> getObjectType() {
        return Car.class;
    }

    @Override
    public boolean isSingleton() {
        return true;
    }
}
```
##### @Conditional
![alt text](/img/java/image6.png)
这个很好玩，spring实现了很多子类
``` java
@ConditionalOnResource(resources = "")
@Conditional(CarContional.class)
@Bean
public Car car1(){
    return new Car();
}
```

##### @Autowired自动装配
如果找到一个，直接注入，找到等多个，按照名字去找,变量名就是名字
``` java
@Autowired
List<Person> persons;

@Autowired
Map<String,Person> personMap;
```
@Resource也能进行自动装配，不过这个是jdk标准规定的东西。
而@Autowired是spring的,而且能开启(required=false)，功能更强
##### @Qualifier("")  @Primary
@Qualifier精确指定，
@Primary指定默认组件,优先级最高
属性名对应优先级最低
##### 利用有参构造器进行装配
spring推荐的方法
``` java
public calss UserDao{
    Dog haha;
    //spring会自动在容器里面找东西吃，然后扔给UserDao
    public UserDao(Dog dog){
        this.haha = dog;
    }
}
```
##### setter注入
其实还可利用setter进行注入，就是给setter上面标注@Autowired
``` java
public void setDog(@Qualifer("dog1") Dog dog){
    this.dog = dog ;
}
```

##### XXXAware感知接口
如果我想在一个类里面使用环境变量等东西，我可以实现Environment接口，然后在自定义一个field接受面量，这样就可以使用了
##### @Value注入值
``` java
@Value("字面值")

@Value("${dog.name:哈哈}") //默认从动态文件application.properties中取出来,可以用冒号赋值默认值
@PropertySource("classpath:cat.properties")  //注意这个注解是加载的意思，而不是仅用这个文件的意思，
// 是在原有文件之上再加载，所以理论上直接放在最外层或者Config层都行

@Value("#{SpEL}")  //表达式
@Value("#{T(java.util.UUID).randomUUID().toString()}")
```
##### 数据源配置
如果我们有开发，测试，生产三套数据源
其实我们想想就知道我们可以用条件注解进行选择
@Profile("")  底层就是@Conditional
``` java
@Prifile("dev")
@Prifile("test")
@Prifile("prod")
@Prifile("default")  //必须得有一个default

@Prifile({"dev",defalut})

//在application.properties中
spring.profiles.active = prod //即可切换
```
### 第二部分
##### 生命周期
默认单例模式：
构造器    //创建周期
->postProcessBeforeInitiallization   
->@Autowired set属性注入->@PostConstruct ->afterPropertiesSet->init   // 初始化周期
->postProcessAfterInitiallization
->容器创建,运行中   //运行周期
->@Predestroy->destroy->destory方法   //销毁周期
* InitializingBean: afterPropertiesSet
* DisposableBean  : destroy
* @PostConstruct 
* @Predestroy
* BeanPostProcessor : 外挂修改器,
    * postProcessBeforeInitiallization
    * postProcessAfterInitiallization

    上面这俩方法是一个统一的拦截器，拦截所有人

举例
* AutowiredAnnotationBeanPostProcessor
我们自己研究源码，实现了一个@UUID的注解，具体见手撕源码
