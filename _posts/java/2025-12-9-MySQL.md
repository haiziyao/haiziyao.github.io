---
layout:     post
title:      "MySQL, are you OK ? "
subtitle:   " \"重逢的开端,MySQL\""
date:       2025-12-9 12:00:00
author:     "HZY"
header-img: "img/java/1.png"
catalog: true
tags:
    - SQL
---
* 关系型数据库
* 非关系型数据库

## SQL : Structured Query Language
* DDL: Data Defination Language
* DML: Data Manipulation Language
* DCL: Data Control Language
#### 启动服务
``` bash
mysql -h 主机名 -P 端口号 -u 用户名 -p密码 

mysql -h localhost -P 3306 -u root -p
Enter password:****

#也可以使用MySQL自带的终端启动工具打开
#密码不要忘了，一般就是123456

mysql -V 
mysql --version

exit
quit
```

``` sql
create database db_name;
use db_name;

show tables;
show tables from db_name;

create table t_name (
    field1  类型,
    field2  类型
);

select * from t_name;

insert int t_name values();

/*查看创建表的详细信息*/
show create table t_name\G

drop table t_name;
drop datebase db_name;

```
#### SELECT
``` sql
select 列名 from table_name;
select * from tb_name;

-- 别名，不建议省略AS
SELECT long_name AS name,
    commission_pct comm,
    FROM tb_name;

-- 甚至可以加入算式
SELECT last_name "Name",
salary*12 "Annual Salary"
FROM em_table;

SELECT DISTINCT a_id,salary
FROM tb_name;

-- MySQL中，空值不等于空字符串，空战占用空间
SELECT emp_id,salary,commission_pct, 12 * salarry * (1 + commission_pct) "anual_sal" 
FROM tb_name;

-- 也有这种需求，增加一个new 字段
SELECT 'A表' as new_field , l_name 
FROM tb_name;

-- 显示表结构 
DESC tb_name;
DESCRIBE tb_name;

/*
- Field：表示字段名称。 
- Type：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。
- Null：表示该列是否可以存储NULL值。
- Key：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。
- Default：表示该列是否有默认值，如果有，那么值是多少。
- Extra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等。
*/

-- 过滤
SELECT * FROM tb_name
WHERE 条件;

```

#### 运算符
``` sql
/*
在Java中，+的左右两边如果有字符串，那么表示字符串的拼接。但是在MySQL中+只表示数值相加。如果遇到非数值类型，先尝试转成数值，如果转失败，就按0计算。（补充：MySQL中字符串拼接要使用字符串函数CONCAT()实现）

整数与浮点数进行运算也会有转型

+ - * / % MOD
*/

SELECT employee_id,salary,salary * 12 annual_sal 
FROM employees;

-- 比较运算符
SELECT FROM tb_name WHERE A=B
SELECT FROM tb_name WHERE A<=>B  --安全等于运算符
<>  != 

 = 
-- 等号两边比较，若类型相同的时候
-- 如果有一个是字符串，则自动转字符串再进行比较
-- 如果有一个为NULL，那么结果也是NULL
 <=>
-- 安全运算符对NULL进行判断
SELECT com_id ,comss_id, FROM employees WHERE  comm_id <=> 
0.40 

!= <>
-- 对于这些不等于的判断，没有空值判断，如果出现空值，结果就是空值

-- 非类型的运算符
IS NULL; 
IS NOTNULL;
LEAST;  -- return min
GREATEST -- return max 
ISNULL  
IN  -- 判断是否在表中
NOT IN 

LIKE    -- 模拟匹配
REGEXP  -- 判断是否符合正则
RLIKE   --   判断值是否符合正则

SELECT emp_id,comm_id FROM tb_name WHERE col_value IS NULL;
SELECT emp_id,comm_id FROM tb_name WHERE col_value com <=> NULL;
SELECT emp_id,comm_id FROM tb_name WHERE ISNULL(col_value);
SELECT emp_id,comm_id FROM tb_name WHERE col_value = NULL;
SELECT

#查询commission_pct不等于NULL
SELECT employee_id,commission_pct FROM employees WHERE commission_pct IS NOT NULL;
SELECT employee_id,commission_pct FROM employees WHERE NOT commission_pct <=> NULL;
SELECT employee_id,commission_pct FROM employees WHERE NOT ISNULL(commission_pct);

-- minVal
SELECT LEAST (1.0,3),l, LEAST('B','a','c'), LEAST(1,NULL,2);
-- 由结果可以看到，当参数是整数或者浮点数时，LEAST将返回其中最小的值；当参数为字符串时，返回字母表中顺序最靠前的字符；当比较值列表中有NULL时，不能判断大小，返回值为NULL。

--maxVal
SELECT LEAST (1.0,3),l, LEAST('B','a','c'), LEAST(1,NULL,2);
-- 那肯定和上面一样

--BETWEEN AND
SELECT salary,emp_id FROM tb_name 
WHERE salary BETWEEN 2500 AND 3500;

-- IN
-- IN运算符用于判断给定的值是否是IN列表中的一个值，如果是则返回1，否则返回0。如果给定的值为NULL，或者IN列表中存在NULL，则结果为NULL。
SELECT emp_id,last_name,manager_id;
FRPM emp_tbale WHERE manager_id IN (100,200,201);

-- NOT IN 

运算符用于判断给定的值是否不是IN列表中的一个值，如果不是IN列表中的一个值，则返回1，否则返回0。

-- LIKE运算符
SELECT first_name FROM emp_table WHERE first_name LIKE '%fhakj'
SELECT first_name FROM emp_table WHERE first_name LIKE '_A_'
-- 这里%占位符表示多个字符，_占位表示一个字符
-- NULL LIKE 'abc' 和 'abc' LIKE NULL的值都是NULL

-- ESCAPE
-- 用来自定义转义字符
SELECT job_id FROM job_table WHERE job_id LIKE 'IT\_%' ESCAP '\'
--我们用escape来自定义转义字符，也可使用其他字符

-- REGEXP 正则表达式
WHERE phone REGEXP '^[0-9]{11}$';

-- 逻辑运算符
NOT  或  !
-- NOT NULL 还是 NULL 
AND  &&
--
OR ||
--
XOR 
-- 位运算符号，这些太阴间了，我感觉用不到

```
#### 排序与分页
``` sql
ORDER BY id ASC; -- 默认升序
ORDER BY id DESC ;
ORDER BY id1,id2 DESC ;

LIMIT 0,10 ;
LIMIT 10 ;

LIMIT 10,10;   -- 11-20条

LIMIT 10 OFFSET 10  -- 8.0新语法，和上面那个一样

SELECT id FROM table_name WHERE id = '' LIMIT 1 
-- 我们如果提前知道只需要返回一条记录，就加上这句话，可以不扫描完整个表，提高效率

```

#### 多表查询
* 等值连接与非等值连接
>对于id连接的是等值连接
对于评定工资等级，用的是between，非等值连接
* 自连接 非自连接
* 内连接 与 外连接
>内连接就是，合并多个表，只有有相对应数据的行合并，对应不上的不要
而外连接就恰恰相反，没对应上的我用NULl替代

``` sql
-- sql中大多采用笛卡尔积，但这在很多时候并不是有效的
-- 所以我们使用 WHERE 关键字加入有效的连接条件
SELECT * FROM tb_1,tb_2 
WHERE tb_1.id = tb_2.id ;

SELECT employees.last_name, departments.department_name,employees.department_id
FROM employees, departments
WHERE employees.department_id = departments.department_id;

-- 使用别名简化
SELECT e.employee_id, e.last_name, e.department_id,
       d.department_id, d.location_id
FROM   employees e , departments d
WHERE  e.department_id = d.department_id;
-- 需要注意的是，如果我们使用了表的别名，在查询字段中、过滤条件中就只能使用别名进行代替，不能使用原有的表名，否则就会报错。

SELECT CONCAT(worker.last_name ,' works for ' 
       , manager.last_name)
FROM   employees worker, employees manager
WHERE  worker.manager_id = manager.employee_id ;

JOIN 
INNER JOIN 
CROSS JOIN 
--都是内连接

-- 一般使用 JOIN 和 ON 进行内连接
SELECT e.id,e.lm,e.id2,d.id
FROM table_e e JOIN table_d d 
ON (e.id = d.id )
-- 多级
SELECT employee_id, city, department_name
FROM   employees e 
JOIN   departments d
ON     d.department_id = e.department_id 
JOIN   locations l
ON     d.location_id = l.location_id;

-- 外连接
LEFT OUTER JOIN;
RIGHT OUTER JOIN;
FULL OUTER JOIN;
FULL JOIN; --Mysql不支持,但是可以用：
LEFT JOIN UNION RIGHT JOIN;

-- 直观地说，右连接就是留下第二个表的所有行，第一个表向它看齐
SELECT e.last_name, e.department_id, d.department_name
FROM   employees e
RIGHT OUTER JOIN departments d
ON    (e.department_id = d.department_id) ;


-- NUION 合并查询
UNION; -- 合并，去重
UNION ALL ;  -- 不去重


SELECT * FROM employees  WHERE email LIKE '%a%'
UNION
SELECT * FROM employees  WHERE department_id>90;


-- SQL JOINS 集合论说是
 
```
![](/img\java\1554979255233.png)
 
 