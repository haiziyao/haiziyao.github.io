---
layout:     post
title:      "Redis!I love Redis ? "
subtitle:   " \"是你\""
date:       2025-12-20 12:00:00
author:     "HZY"
header-img: "img/java/1.png"
catalog: true
tags:
    - NoSQL
---

#### 初始Redis

##### 什么是NoSql
原子性，一致性，隔离性，持久性

* 结构化与非结构化
* 关联与非关联
* sql查询与非sql
* 是否支持事:ACID与BASE
* 存储方式
* 扩展性:垂直与水平(是否支持分布式)

##### 认识Redis
* k-v数据库：支持多种类型
* 单线程，具有原子性
* 低延迟，速度快(基于内存，IO多路复用，良好的编码)
* 支持数据持久化
* 支持主从集群，分布集群
##### 安装Redis
* 安装路径`/usr/local/bin`
* 启动 `redis-server`
* redis默认是前台启动，我们要修改为后台启动
    * /usr/local/src/redis-版本号/redis.conf
    * 修改配置文件

        ``` bash
        bind 127.0.0.1  -> 0.0.0.0
        daemonize no -> yes     #守护进程
        requirepass  123456 #设置密码
        port 6379
        dir .
        databases 1 #默认是16个库
        maxmemory 512mb
        logfile "redis.log"
        ```
    * redis-server redis.conf #这里要写好路径位置
    * ps -ef | grep redis

* 开机启动脚本
    * 写脚本

    ``` 
    [Unit]
    Description=redis-server
    After=network.target
    ​
    [Service]
    Type=forking
    ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf
    PrivateTmp=true
    ​
    [Install]
    WantedBy=multi-user.target
    ```
    * 重启服务：sustemctl daemon-reload
    * systemctl start redis 
    * systemctl enable redis

##### Redis命令行客户端
``` bash
redis-cli [options] [commonds]
redis-cli -h 127.0.0.1 -p 6379 -a 密码

redis-cli
AUTH 密码
```
#### Redis常见命令

##### Redis数据结构
key一般是String
value多样
* 基础类型
    * String 
    * Hash
    * List
    * Set
    * SortedSet
* 特殊类型 
    * GEO
    * BitMap
    * HyperLog

##### 命令
* help 
* keys 
    * keys [pattern]不建议使用，因为是模糊查询，速度慢，容易堵塞
* DEL
    * DEL k1 k2 k4 
* EXISTS 
    * exist key
* EXPIRE   
    * expire key time
    * expire age 20 
* TTL
    * TTL key
    * 值为-1：永久有效
    * 值为-2：死掉了

##### 字符串String
String虽然叫做字符串，但是对于存储数字，如果我用字符数组去存，占用空间肯定很大，所以底层是编码为数字再到二进制数据存储数字，所以String底层不一定是String，你甚至可以把图片存为"String"

最大空间不能超过512M
* msg
* num 
* score

命令:
* set key value ：设置或更改
* get key
* mset k1 v1 k2 v2 ：批量set
* mget k1 k2 :
* incr key : 让value自增1
* incrby key increament : 自定义自增
    * incrby ket -1 :实现自减 (虽然说有自减这个操作，但是我们没有定义)
* incrbyfloat: 浮点数自增，必须定义步长
* setnx key val : 只增加，如果有就不管了
    * set key val nx :一样的用法
* setex key seconds value
    * set key value ex seconds

* key层级结构
    项目：业务：类型：id
##### Hash类型
* HSET: 
    * hset key field value
* HGET 
    * hget key field
* HMSET:
    * hmset key f1 v1 f2 v2
* HMGET 
    * hmget key f1 f2 
* HGETALL (输出f1,v1,f2,v2)
    * hgetall key
* HKEYS 
* HVALS
* HINCRBY:
* HSETNX: 判断field是否存在
    * hsetnx key field value

##### List类型
底层可以看做双向链表
* 有序
* 元素可重复
* 插入删除块
* 查询速度一般

* LPUSH key element [element]
* LPOP key
* RPUSH key element
* LPOP key
* LRANGE key start end
    * lrange key 1 2 
* BLPOP 和 BRPOP ：与LOPOP和RPOP相似，但是可以在没有元素的时候等待指定时间，而不是直接返回nil
    * BLPOP key 100  等100s

##### Set
* 无序
* 不可重复
* 查找快
* 支持集合操作

* SADD key member
* SREM key member
* SCARD key: 返回总数
* SISMEMBER key member
* SMEMBERS: 获取所有元素

* SINTER k1 k2 ：交集
* SDIFF k1 k2 : 差集 k1差k2
* SUNION k1 k2 : 并集

##### SortedSet
* 可排序
* 元素不重复
* 查询速度快
* 底层是跳表和hash表
* 经常用来实现排行榜

* ZADD key score member
* ZREM key member
* ZSCORE key member
* ZRANK key member
* ZCARD key 
* ZCOUNT key min max :根据score获得count,两端都是闭合[0,80]
* ZINCRBY key increment member 
* ZRANGE key min max : 根据排名获取元素
* ZRANGEBYSCORE key min max :
* ZDIFF,ZINTER,ZUNION

* 使用ZREVRANGE可使用降序排序，都可以用ZREV

#### 客户端
* jedis
    * 以命令作为方法名，简单实用
    * 线程不安全，多线程环境需要连接池
* lettuce 
    * netty实现的，线程安全
    * 支持哨兵，集群，管道
* Redisson 
    * 基于Redis实现的分布式，

* Spring Data Redis : 底层可有jedis和lettuce实现


//注意事项，记得放开redis的端口，要么就直接关闭防火墙
##### Jedis入门
``` java
@SpringBootTest
class RedisApplicationTests {
    private Jedis jedis;
    @BeforeEach
    void connect(){
        jedis = new Jedis("192.168.200.130",6379);
        jedis.auth("123456");
        jedis.select(1);
    }
    @AfterEach
    void disconnect(){
        if(jedis != null){
            jedis.close();
        }
    }

    @Test
    void contextLoads() {
        jedis.set("hello", "world");
        String hello = jedis.get("hello");
        System.out.println(hello);
    }
}
```

##### jedis线程池
![alt text](/img/java/redis1.png)

##### Spring Data Redis
* 提供对不同客户端的整合
* 提供 RedisTemplate来进行
* 支持Redis的发布订阅模型
* 支持Redis哨兵和集群
* 支持Lettuce的响应式编程
* 支持序列化和反序列化
* 支持基于Redis的JDKCollection实现

依赖
* Redis
* 连接池 commons
* 配置redis
    * spring.data.redis.host=192.168.200.130
    * spring.data.redis.password=123456
    * 其他应该都默认配置好了

``` java
@SpringBootTest
public class Test2 {
    @Autowired
    private RedisTemplate redisTemplate;
    @Test
    public void test() {
        redisTemplate.opsForValue().set("name", "hzy");
        System.out.println(redisTemplate.opsForValue().get("name"));
    }
}

//但是打开redis，存的竟然是这个
//\xAC\xED\x00\x05t\x00\x03name
//\xAC\xED\x00\x05t\x00\x03hzy
//底层默认序列化了
//这样肯定有很多弊端，比如占用内存高，比如难看
//解决方法就是，我们自己配
@Configuration
public class RedisConfig {
 
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory){
        // 创建RedisTemplate对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 设置连接工厂
        template.setConnectionFactory(connectionFactory);
        // 创建JSON序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = 
            							new GenericJackson2JsonRedisSerializer();
        // 设置Key的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置Value的序列化
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        // 返回
        return template;
    }
}

    public void test() {
        redisTemplate.opsForValue().set("name",new Person("hzy",88));
        System.out.println(redisTemplate.opsForValue().get("name"));
    }

/*
{
  "@class": "com.xjtuhelper.redis.bean.Person",
  "name": "hzy",
  "age": 88
}
*/
```
##### StringRedisTemplate
"@class": "com.xjtuhelper.redis.bean.Person" 
序列化和反序列化都得靠这个，但是对于redis而言，我们放在内存中，怎么能让这么一个东西占用空间呢，所以我们统一用String存，自己手动序列化

* 我们直接使用StringRedisTemplate

``` java
private ObjectMapper objectMapper=new ObjectMapper();
@Test
public void test() throws JsonProcessingException {
    Person hzy = new Person("hzy", 111);
    String json = objectMapper.writeValueAsString(hzy);
    stringRedisTemplate.opsForValue().set("hzy", json);
    String s = stringRedisTemplate.opsForValue().get("hzy");
    Person person = objectMapper.readValue(s, Person.class);
    System.out.println(person);
}
```

### Redis实战--黑马点评
* 短信登录
* 查询缓存
* 达人探店
* 优惠券秒杀
* 好友关注
* 附近商户
* 用户签到
* UV统计

#### 导入项目
遇到了一个很恶心的ERROR
>java: 警告: 源发行版 17 需要目标发行版 17
#### 短信登录
* 基于Session的短信验证码登录

![alt text](image.png)

Redis代替Session解决session共享问题

对于用户信息，用String还是Hash???
用String

#### 商户查询缓存

##### 什么是缓存
* 缓存的作用 
    * 降低后端负载
    * 提高读写效率
    * 降低响应时间
* 缓存的成本
    * 数据一致性成本
    * 代码维护成本
    * 运维成本
#### 开发经验
* 用String 还是 hash ？
    * 使用场景不同

    >我们这个缓存，缓存的是一个不会变的值，如果变了，其实是我们从数据库又读了一遍，所以针对这种情况我们直接使用string而不是hash

#### 缓存更新策略
* 内存淘汰
    * Redis自己的淘汰机制
* 超时剔除
    * 一致性一般
    * 维护成本低
* 主动更新
    * 一致性好
    * 维护成本高

面对业务进行选择
* 低一致性需求
* 高一致性需求

主动更新策略分类
* Cache Aside Pattern
    * coder自己写调用缓存的逻辑
* Read/Write Through Pattern
    *  我们不用管，服务会自己决定用redis还是sql
    * 我们只需要调服务就行
* Write Behind Caching Pattern
    * 调用者只操作缓存
    * 其他线程异步将缓存数据持久到数据库


最终选择Cache Aside Pattern 
* 删除缓存还是更新缓存
    * 更新缓存:

    >每次数据库更新，缓存就更新，无效写操作较多
    * 删除缓存:

    >每次数据更新，我直接把缓存删了，你下次有人访问的时候再读。所以包选这个啊
* 如何保证缓存与数据库的操作同时成功或失败
    * 单体系统：把缓存和数据库操作放在一个事务里面
    * 分布式系统：利用TCC等分布式事务方案
* 先操作缓存还是先操作数据库？多线程并发视角
    * 先删除缓存，再更新数据库： 拿到旧数据，并存入缓存，更新缓存失效
    * 先更新数据库，再删除缓存：也是拿到旧数据，但可能性耕地

#### 缓存穿透
当有恶意的小人查一堆空id(或者其他)，redis查不到，db也查不到，如果他搞10000次请求，那就炸了，10000请求到数据库上
* 缓存空对象(使用这个)
    * 实现简单，维护方便
    * 缺点：
        * 数据不一样
        * 额外的内存消耗
* 布隆过滤(经典加一层)
    * 存在误判的问题