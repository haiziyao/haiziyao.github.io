---
layout:     post
title:      "Hello Vue"
subtitle:   " \"let's us learn Vue\""
date:       2025-11-20 12:00:00
author:     "HZY"
header-img: ""
catalog: true
tags:
    - Vue
---
##### 写在前面
>本篇文章为作者再次学习vue的学习记录
目标效果为：能够做出一个“社团管理系统”的ui
之后配合作者的后端基础，争取在寒假中完成此项目
本篇文章持续更新，不会再开一篇新文章
 
#### Vue是什么
一个 构建用户界面 的 渐进式 框架
* 构建用户界面 ：基于数据动态渲染页面
* 渐进式 ：循序渐进的学习
* 框架 ： 一套完整的项目解决方案，提升开发效率 

#### Vue上手
* 准备容器
* 引包(开发/生产)
* 创建实例
* 指定配置：
	* el ：挂载点
	* data ：数据

#### 插值表达式
* 可以是js语法，可以是算式
* {{表达式}}   
	* 可以使用函数，入toUpperCase()
	* 可以使用三元运算符
	* 不能使用语句 if，for
	* 不能在标签属性使用

#### 响应式数据
* 访问 : name.data
* 修改 : name.data = value

#### 开发者工具
在极简插件下载插件
#### Vue指令
带有v-前缀的 的特殊 标签属性

* v-html = "表达式"  --> InnerHtml 
```
 解释：我们如果想把<a>标签放入一个div里面
 如果只是在msg中写<a>
 那么只会被解析为字符串
 解决办法就是设置属性v-html = "msg"
```
* v-show = "表达式"  表达式的值是true才显示
* v-if = " 表达式" 表达式的值是true才显示

> v-show本身还存在，只是给了css中dispaly进行赋值：适用于频繁切换隐藏；v-if则是是否需要创建或益处这个元素节点

* v-else
* v-else-if
* v-on  : 注册事件    可以用@代替    (实现计时器) 

> v-on: 事件名 = "内联语句"     可以直接用@替换v-on:
>
> v-on : 事件名 = "methods"  注意使用变量的是否可以使用this，或者通过实例去访问
>
> @click= fn  这样其实就可以了，
>
> @click = fn(a,b) 这样就可以传入参数了

* v-bind : 属性名 = "表达式"

> v-bind :src="imgurl"

* v-for =" " : 基于数据循环，可以多次渲染

>this.tasks = this.tasks.**filter**(item=>item.id!==id)

* v-model=' ' : 双向数据绑定，给表单数据使用

#### 指令修饰符
* 按键修饰符
	* @keyup.enter="fn" : 想当于fn(e){if(e.key===)}
* 我去
	* v-model.trim="var"
	* v-model.number=""
*  阻止冒泡
	* @click.stop=""
*  阻止默认行为
	* @click.prevent=""

#### 样式控制
* 增强class
``` html
:class = "{类名1:布尔1,类名:布尔2}"
:class = "[类名1，类名2，类名3]"
```
* 增强style
```
:style="样式对象"
:style = "{css属性名1:val1,name2:val2}"

:style = "{width=percent+'%'}"
```
注意对于font-size来说，因为-不被识别，所以可以使用‘’括起来，或者转为驼峰命名法
#### v-model与表单元素
* input
* textarea
* input type="radio" ：记得设置name和value
* select option：记得设置val
#### 计算属性：会自动计算
1. 声明在computed中
2. 和变量一样使用{{}}
``` js 
computed:{
	totalCount(){
		//直接随便用
		//复习一下reduce函数
		let total = this.list.reduce((sum,item)=>sum+item.num,0)
		return  结果
	}
}
```
#### computed计算属性  与   methods方法
* 计算属性是有缓存的

>这也是为什么能作为变量直接使用的原因，但是对于moethod，每次都需要调用数据，就是执行了一次函数，所以肯定不能看作为变量。
* 计算属性作为变量的可变性，可修改性

``` js
computed{
	Example : {
		get(){

		},
		set(val){

		}
	}
}
```

#### watch监视器
监视数据变化，执行一些业务逻辑或异步请求
* 简单写法：
``` js
watch:{
	数据属性名(newval,oldval){

	},
	'对象属性名'(newval,oldval){

	}
}
```
>忘记了js中对接口发请求的方式了,这里老师写了一个防抖的程序，这个方面我还没有学会

``` js
  watch :{
	'obj.words'(newValue){
		clearTimeout(this.timer)
		this.timer = setTimeout(async()=>{
			const res = await axios({
				url:'',
				params:{
					words:newValue
				}
			})
			this.result = res.data.data
		},1000)
	}
  }
```

* 完整写法
	1. deep : true 对复杂类型进行深度监视
	2. immediate : true 初始化立刻执行 

``` js
watch : {
	obj : {
		deep : true,
		handler(newval){
			//业务逻辑
		},
		immediate : true 
	}

}

```

#### Js里面的常用函数

>这个部分我可能要多次来写了，因为，在vue开发过程中发现了很多问题，就是js基础不牢固

* list.filter : 过滤，保留true
* list.every : 是否全部满足
* list.reduce : 累加，汇总，合并
* list.forEach : 遍历数组但不返回
* list.map : 根据原有数据返回一个新数组 
``` js
 
const newlist = this.list.filter(ele => item.isLive)
<li v-for="elem in list.filter(t=>t.islive)"  :key="elem.id"></li>

const result = this.list.every(item=> 条件)
 
const result = this.list.reduce((newval,item)=>{return nextval;},primVal)
const sum = this.nums.reduce((all,n)=>all+n,0)

list.forEach((item,index,array)=>{
	//进行操作
});

const result = list.map((item,index,array)=>{
	retrun 
})
const name = users.map(user=>user.name) //提取字段
const newdata = this.list.map((elem,index)=>{
	id : index+1.
	name : elem.name
})
```

* 转存json到本地 : 持久化操作 (这个部分我跳过了好多次，需要及时复习)
``` js
localStorage.setItem('list',JSON.stringify(newValue))

fruitList : JSON.parse(localStorage.getItem('list')) || []
//好好想想我为什么要|| []  
//当用户把localStorage清除了，fruitList就成了null,整个页面都会崩溃
```
**请分析我上面为什么要使用 || []**

#### Vue的生命周期 和 生命周期 的四个阶段
定义 ： 一个Vue实例从 创建 到 销毁 的整个状态
生命周期四个阶段 ： 创建->挂载->更新->销毁


#### Vue生命周期函数（钩子函数）
* beforeCreate()
* created() : 发送初始化渲染请求
* beforeMount()
* mounted() : 此步就已经完成的页面的渲染，可以操作DOM
* beforeUpdate()
* updated() : 修改数据，更新视图
* beforeDestory() : 释放资源
* destoryed()

``` js
	
	async created(){
		const res = await axios.get(url)
		//渲染页面完成前 拿到数据
	}

	//进入页面后搜索框获取焦点
	//vue中 autofocus不管用
	async mounted(){
		document.querySelector('#id').focus()
	}

```
#### 接口使用
``` js
async add(){
	const res = await axios.post("url",{
		//your data
	})
}
async del(){
	const res = await axios.del("url",{
		//necessity
	})
}

```

#### Vue Cli
``` bash
vue create [ProjectName]
vue run [ServerName]
```
* /public
	* index.html  //模板文件
* /src
	* assets
	* components
	* App.vue
	* main.js 
		1. 导入Vue
		2. 导入App.vue
		3. Vue实例化
* package.json

#### 组件化开发 & 根组件
* 组件化 ：一个页面可以拆分成一个个组件，每个组件有着自己独立的结构，样式，行为
* 根组件: App.vue  
	1. template : 结构
	2. script : js逻辑
	3. style : 样式(可以支持less)
		* ```<style lang="less">```

####  普通组件的注册使用
1. 局部注册
	* components创建vue文件
	* 导入 & 局部注册
	``` js
		import VueComponet form './components/VueComponent'
		export default{
			components : {
				VueComponent : VueComponent,
				VueComponent //如果是驼峰式，就可以这样省略着写了
			}
		}
	
	```

2. 全局注册 ： 在所有组件内都能使用
	* 创建vue文件
	* 在main.js中进行全局注册
	``` js
		import HmButton from './components/HmButton'
		vue.component('HmButton',HmButton)

	```


#### 组件的三大组成部分
* 结构
	* 只有一个根组件
* 样式
	* 全局样式：默认样式为全局样式
	* 局部样式：给style加上scoped属性
* 逻辑
	* data 必须是一个函数（组件的数据必须由函数提供）
	``` js
		<script>
			export default{
				data : {
					return {
					//这里面写东西
					count : 999
					}
				}
			}
		</script>
	```

#### 组件通信
* 组件内的数据本来是独立的
* 通过组件通信传递数据
* 组件关系
	* 父子关系
		props  | &emit
		1. props : 任意类型
		``` js
		//父组件
		<Son :name="data_name"> 
		//子组件
		props : ['name'] 
		```

		2. $emit
		``` js
		//子组件
		methods:{
			handleClick(){
				this.&emit('消息名称，类似click','')
			}
		}
		//父组件
		<Son :title="data_name" @消息名称 = "fn">
		methods : {
			fn(){

			}
		}
		```

	* 非父子关系
		provide | inject | eventbus
		1. eventbus 
		``` js
		//先创建EventBus.js
		import Vue from 'vue'
		const Bus = new Vue()
		export default Bus
		//发送方
		import Bus from '../utils/EventBus'
		export default {
			methods : {
				clickSend(){
					Bus.$emit('sendMsg',data)
				}
			}
		}
		//接收方收听Bus
		import Bus from '../utils/EventBus'
		export default{
			create(){
				Bus.$on('snedMsg',(data)=>{

				})
			}
		} 
		```

		2.provide & inject 
		``` js
		//跨层级访问数据
		export default{
			provide(){ 
				//简单类型：非响应式
				color : this.color
				//复杂类型：响应式的
				data : {

				}
			}
		}
		 
		export default{
			inject : ['color']
		}
		```
	* 通用方案
		vuex

####  prop校验
* 类型校验
	``` js 
	props:{
		w : Number
		str : String
		bool : Boolean
	}
	```

* 非空校验
* 默认值
* 自定义校验

``` js 
props : {
	value : {
		type : Number,
		required : true,
		default : 默认值,
		validator(value){
			//自行校验逻辑
			return bool
		} 
	}
}

```

#### prop & data
**单向数据流**
* data 是自己的数据，随便改
* prop 的数据是别人的，不能随便改

#### v-model的原理

