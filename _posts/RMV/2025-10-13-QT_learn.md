---
layout:     post
title:      "Qt learn"
subtitle:   " \"let us learn Qt deeply\""
date:       2025-10-28 05:00:00
author:     "HZY"
header-img: ""
catalog: true
tags:
    - C++
---
##### 基本类型
##### IO
``` cpp
qDebug()<<"";
qDebug("%s %d","hello",1);
qInfo()<<
qWarning()<<
qCritical()<<

qFatal()//这个不能使用流输出
```
##### QByteArray
``` cpp
append(qbarr)
push_front(qbarr)
push_front(qbarr)
insert(int,qbarr)
remove(pos,len)
chop(int) //截断最后几个
```

##### QPushButton
``` cpp
QPushButton *btn = new QPushButton;
btn->setParent(this);
btn->setText("a");
btn->move(100,100);

QPushButton *btn = new QBushBotton("btn",this);

```

##### 创建对象的时机
平安无事
>{
    QWidget window;
    QPushButton quit("Quit", &window);
}

程序崩溃
>{
    QPushButton quit("Quit");
    QWidget window;
    quit.setParent(&window);
}

#### 信号与槽机制
##### 基本认识
``` cpp
QPushButton * quitbtn = new QPushButton("关闭窗口",this);
connect(quitBtn,&QPushButton::clicked,this,&MyWidget::close);

connect(sender, signal, receiver, slot);
```
**Signals**
* clicked(bool checked = false)
* pressed()
* released()
* toggled(bool checked)
##### 自定义信号
* 声明在类的signals域下
* 没有返回值，void类型的函数
* 只有函数声明，没有定义
* 可以有参数，可以重载
* 通过emit关键字来触发信号，形式：emit object->sig(参数);
``` cpp
signals:
    void hungry();

void MyWidget::ClassIsOver(){
   
    emit teacher->hungry();
}
```
##### 自定义槽
* qt4 必须声明在 private/public/protected slots域下面，qt5之后可以声明public下，同时还可以是静态的成员函数，全局函数，lambda表达式
* 没有返回值，void类型的函数
* 不仅有声明，还得要有实现
* 可以有参数，可以重载
``` cpp
public slots:
       void treat();

void Student::treat(){
       qDebug() << "Student treat teacher";
}


//lambda
connect(btn,&QPushButton::clicked,[=](){
        qDebug()<<"Clicked";
});
```

#### QMainWindow
>QMainWindow是一个为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个停靠部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础，如文本编辑器，图片编辑器等。
##### 菜单栏
``` cpp
QMenuBar *  menuBar() const; //调用函数自动创建

QAction* addMenu(QMenu * menu);
QMenu* addMenu(const QString & title);
QMenu* addMenu(const QIcon & icon, const QString & title);

QAction* activeAction() const;
QAction* addAction(const QString & text);
QAction* addAction(const QIcon & icon, const QString & text);
QAction* addAction(const QString & text, const QObject * receiver,
const char * member, const QKeySequence & shortcut = 0);
QAction* addAction(const QIcon & icon, const QString & text, 
const QObject * receiver, const char * member, 
const QKeySequence & shortcut = 0);

//示例
// 在 QMainWindow 子类中添加菜单栏、菜单和动作
void MainWindow::initMenu() {
    QMenuBar *bar = menuBar(); // 获取菜单栏
    QMenu *fileMenu = bar->addMenu("文件"); // 添加“文件”菜单
    QAction *newAct = fileMenu->addAction("新建", this, &MainWindow::newFile, QKeySequence::New); // 添加“新建”动作并绑定槽函数、快捷键
    QAction *openAct = fileMenu->addAction(QIcon("open.png"), "打开", this, &MainWindow::openFile); // 带图标的“打开”动作
}
```

##### 工具栏
``` cpp
Qt::LeftToolBarArea           //停靠在左侧
Qt::RightToolBarArea         //停靠在右侧
Qt::TopToolBarArea           //停靠在顶部
Qt::BottomToolBarArea   //停靠在底部
Qt::AllToolBarAreas          // 以上四个位置都可停靠

setAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea）
setFloatable（trueOrFalse）
setMoveable（trueOrFalse）
```

##### 状态栏
一个QMainWindow的程序最多只有一个状态栏。QMainWindow中可以有多个的部件都使用add…名字的函数，而只有一个的部件，就直接使用获取部件的函数，如menuBar。同理状态栏也提供了一个获取状态栏的函数statusBar()，没有就自动创建一个并返回状态栏的指针。
``` cpp
 QMenuBar *	menuBar() const;

void addWidget(QWidget * widget, int stretch = 0);
//插入小部件
int	insertWidget(int index, QWidget * widget, int stretch = 0);
//删除小部件
void removeWidget(QWidget * widget);

void addPermenentWidget (QWidget *widget, int stretch = 0);
```
##### 停靠部件（也成为铆接部件、浮动窗口）

##### 核心部件（中心部件）

####  跳过

#### QDialog 对话框